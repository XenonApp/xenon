{"version":3,"sources":["../../../../src/config/default/command/search.js"],"names":["ui","xenon","fs","session","filterExtensions","indexToLine","text","index","s","substring","match","length","getLine","line","lines","split","trim","MAX_RESULTS","stringIsText","isText","sampleSize","Math","min","i","charCode","charCodeAt","phraseParser","phrase","quoted","regex","caseInsensitive","skipWhitespace","forloop","pathPattern","escapeRegExp","str","replace","wildcardToRegexp","module","exports","info","append","results","fileList","parsedPhrase","console","log","goto","then","listFilesOfKnownFileTypes","fileList_","pathRegex","RegExp","filter","filename","exec","setText","phraseText","phraseRegex","toLowerCase","reverse","searchFile","path","pop","indexOf","readFile","matchIdx","searchText","m","error","catch","err","message"],"mappings":"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","file":"search.js","sourcesContent":["var ui = xenon.ui;\nvar fs = xenon.fs;\nvar session = xenon.session;\n\nvar filterExtensions = [\"pdf\", \"gz\", \"tgz\", \"bz2\", \"zip\",\n    \"exe\", \"jpg\", \"jpeg\", \"gif\", \"png\"];\n\nfunction indexToLine(text, index) {\n    var s = text.substring(0, index);\n    return (s.match(/\\n/g) || []).length + 1;\n}\n\nfunction getLine(text, index) {\n    var line = indexToLine(text, index);\n    var lines = text.split(\"\\n\");\n    return lines[line - 1].trim();\n}\n\nvar MAX_RESULTS = 1000;\n\n/**\n * Function to check if the string is text or binary, based on the\n * answers here:\n *   http://stackoverflow.com/questions/10225399/check-if-a-file-is-binary-or-ascii-with-node-js\n */\nfunction stringIsText(text) {\n    var isText = true;\n    var sampleSize = Math.min(100, text.length);\n    for (var i = 0; i < sampleSize; i++) {\n        var charCode = text.charCodeAt(i);\n        if (charCode === 65533 || charCode <= 8) {\n            isText = false;\n            break;\n        }\n    }\n    return isText;\n}\n\nfunction phraseParser(phrase) {\n    var text = '';\n    var quoted = false;\n    var regex = false;\n    var caseInsensitive = false;\n    // The search phrase part\n    for (var i = 0; i < phrase.length; i++) {\n        if (i === 0 && phrase[i] === '\"') {\n            quoted = true;\n        } else if (phrase[i] === '\"') {\n            i++;\n            break;\n        } else if (quoted) {\n            text += phrase[i];\n        } else if (phrase[i] === ' ') {\n            break;\n        } else {\n            text += phrase[i];\n        }\n    }\n    skipWhitespace();\n    if (phrase[i] === '-') { // options\n        i++;\n        forloop: for (; i < phrase.length; i++) {\n            switch (phrase[i]) {\n                case 'i':\n                    caseInsensitive = true;\n                    break;\n                case 'e':\n                    regex = true;\n                    break;\n                default:\n                    break forloop;\n            }\n        }\n    }\n    skipWhitespace();\n    var pathPattern = phrase.substring(i);\n    return {\n        text: text,\n        regex: regex,\n        caseInsensitive: caseInsensitive,\n        pathPattern: pathPattern\n    };\n\n    function skipWhitespace() {\n        while (phrase[i] === ' ') {\n            i++;\n        }\n    }\n}\n\nfunction escapeRegExp(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\n\nfunction wildcardToRegexp(str) {\n    str = escapeRegExp(str);\n    str = str.replace(/\\\\\\*/g, \".*\");\n    return \"^\" + str + \"$\";\n}\n\nmodule.exports = function(info) {\n    var phrase = info.phrase;\n\n    function append(text) {\n        session.append(\"zed::search\", text, function() {});\n    }\n    var results = 0;\n    var fileList;\n    if (!phrase) {\n        // Need to throw to jump out here\n        return;\n    }\n    var parsedPhrase = phraseParser(phrase);\n    console.log(\"Parsed phrase\", parsedPhrase);\n    session.goto(\"zed::search\").then(function() {\n        return fs.listFilesOfKnownFileTypes();\n    }).then(function(fileList_) {\n        var pathRegex = new RegExp(wildcardToRegexp(parsedPhrase.pathPattern));\n\n        fileList = fileList_;\n        fileList = fileList.filter(function(filename) {\n            return parsedPhrase.pathPattern ? pathRegex.exec(filename) : true;\n        });\n        session.setText(\"zed::search\", \"Searching \" + fileList.length + \" files for '\" + parsedPhrase.text + \"'...\\nPut your cursor on the result press Enter to jump.\\n\");\n\n        var phraseText = parsedPhrase.text;\n        if (parsedPhrase.regex) {\n            var phraseRegex = new RegExp(parsedPhrase.text, \"g\");\n        }\n        if (parsedPhrase.caseInsensitive) {\n            phraseText = phraseText.toLowerCase();\n        }\n        fileList.reverse();\n\n        function searchFile() {\n            var path = fileList.pop();\n            if (!path) {\n                return;\n            }\n            if (results >= MAX_RESULTS) {\n                return;\n            }\n\n            if (path === \"/tags\" || path.indexOf(\"zed::\") === 0) {\n                return;\n            }\n\n            return fs.readFile(path).then(function(text) {\n                if (!stringIsText(text)) {\n                    return;\n                }\n                var matchIdx = 0;\n                var searchText = parsedPhrase.caseInsensitive ? text.toLowerCase() : text;\n                if (parsedPhrase.regex) {\n                    var lines = searchText.split(\"\\n\");\n                    var m;\n                    for (var i = 0; i < lines.length; i++) {\n                        while (m = phraseRegex.exec(lines[i])) {\n                            append(\"\\n\" + path + \":\" + (i + 1) + \"\\n\\t\" + lines[i] + \"\\n\");\n                            results++;\n                            if (results >= MAX_RESULTS) {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    while ((matchIdx = searchText.indexOf(phraseText, matchIdx)) !== -1) {\n                        append(\"\\n\" + path + \":\" + indexToLine(text, matchIdx) + \"\\n\\t\" + getLine(text, matchIdx) + \"\\n\");\n                        matchIdx++;\n                        results++;\n                        if (results >= MAX_RESULTS) {\n                            break;\n                        }\n                    }\n                }\n            }, function() {\n                console.error(\"Could not read file: \" + path);\n                // If a few files fail that's ok, just report\n            }).then(function() {\n                return searchFile();\n            });\n        }\n\n\n        return searchFile();\n    }).then(function() {\n        if (results === 0) {\n            append(\"\\nNo results found.\");\n        } else {\n            append(\"\\nFound \" + results + \" results.\");\n        }\n    }).\n    catch (function(err) {\n        console.error(\"Got error\", err);\n        append(\"\\nGot error: \" + err.message);\n        throw err;\n    });\n};\n"]}