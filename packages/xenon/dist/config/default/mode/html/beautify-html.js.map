{"version":3,"sources":["../../../../../src/config/default/mode/html/beautify-html.js"],"names":["module","exports","style_html","html_source","options","multi_parser","indent_size","indent_character","max_char","brace_style","unformatted","indent_char","Infinity","Parser","pos","token","current_mode","tags","parent","parentcount","parent1","tag_type","token_text","last_token","last_text","token_type","Utils","whitespace","split","single_token","extra_liners","in_array","what","arr","i","length","get_content","input_char","content","space","input","charAt","join","line_char_count","push","indent_level","indent_string","get_contents_to","name","reg_match","RegExp","lastIndex","reg_array","exec","end_script","index","substring","record_tag","tag","retrieve_tag","temp_parent","get_tag","peek","tag_start","tag_end","orig_pos","orig_line_char_count","get_unformatted","print_newline","tag_complete","tag_index","indexOf","tag_check","toLowerCase","is_unformatted","comment","splice","unindent","output","delimiter","orig_tag","get_token","type","substr","tag_name_type","get_full_indent","level","Array","next_tag","printer","js_source","ignore","pop","print_token","text","indent","t","tag_name","match","tag_extracted_from_last_output","_beautifier","js_beautify","css_beautify","indent_scripts","script_indent_level","indentation","replace","white","_level","reindent"],"mappings":"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","file":"beautify-html.js","sourcesContent":["/*\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <elfz@laacz.lv>\n    http://jsbeautifier.org/\n\n\n  You are free to use this in any way you want, in case you find this useful or working for you.\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_size (default 4)          — indentation size,\n    indent_char (default space)      — character to indent with,\n    max_char (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_size': 2,\n      'indent_char': ' ',\n      'max_char': 78,\n      'brace_style': 'expand',\n      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u']\n    });\n*/\n\nmodule.exports = style_html;\n\n\nfunction style_html(html_source, options) {\n//Wrapper function to invoke all the necessary constructors and deal with the output.\n\n  var multi_parser,\n      indent_size,\n      indent_character,\n      max_char,\n      brace_style,\n      unformatted;\n\n  options = options || {};\n  indent_size = options.indent_size || 4;\n  indent_character = options.indent_char || ' ';\n  brace_style = options.brace_style || 'collapse';\n  max_char = options.max_char == 0 ? Infinity : options.max_char || 250;\n  unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n\n  function Parser() {\n\n    this.pos = 0; //Parser position\n    this.token = '';\n    this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\n    this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\n      parent: 'parent1',\n      parentcount: 1,\n      parent1: ''\n    };\n    this.tag_type = '';\n    this.token_text = this.last_token = this.last_text = this.token_type = '';\n\n    this.Utils = { //Uilities made available to the various functions\n      whitespace: \"\\n\\r\\t \".split(''),\n      single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML\n      extra_liners: [],//'head,body,/html'.split(','), //for tags that need a line of whitespace before them\n      in_array: function (what, arr) {\n        for (var i=0; i<arr.length; i++) {\n          if (what === arr[i]) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n\n    this.get_content = function () { //function to capture regular content between tags\n\n      var input_char = '',\n          content = [],\n          space = false; //if a space is needed\n\n      while (this.input.charAt(this.pos) !== '<') {\n        if (this.pos >= this.input.length) {\n          return content.length?content.join(''):['', 'TK_EOF'];\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++;\n        this.line_char_count++;\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n          if (content.length) {\n            space = true;\n          }\n          this.line_char_count--;\n          continue; //don't want to insert unnecessary space\n        }\n        else if (space) {\n          if (this.line_char_count >= this.max_char) { //insert a line when the max_char is reached\n            content.push('\\n');\n            for (var i=0; i<this.indent_level; i++) {\n              content.push(this.indent_string);\n            }\n            this.line_char_count = 0;\n          }\n          else{\n            content.push(' ');\n            this.line_char_count++;\n          }\n          space = false;\n        }\n        content.push(input_char); //letter at-a-time (or string) inserted to an array\n      }\n      return content.length?content.join(''):'';\n    }\n\n    this.get_contents_to = function (name) { //get the full content of a script or style to pass to js_beautify\n      if (this.pos == this.input.length) {\n        return ['', 'TK_EOF'];\n      }\n      var input_char = '';\n      var content = '';\n      var reg_match = new RegExp('\\<\\/' + name + '\\\\s*\\>', 'igm');\n      reg_match.lastIndex = this.pos;\n      var reg_array = reg_match.exec(this.input);\n      var end_script = reg_array?reg_array.index:this.input.length; //absolute end of script\n      if(this.pos < end_script) { //get everything in between the script tags\n        content = this.input.substring(this.pos, end_script);\n        this.pos = end_script;\n      }\n      return content;\n    }\n\n    this.record_tag = function (tag){ //function to record a tag and its parent in this.tags Object\n      if (this.tags[tag + 'count']) { //check for the existence of this tag type\n        this.tags[tag + 'count']++;\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n      }\n      else { //otherwise initialize this tag type\n        this.tags[tag + 'count'] = 1;\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n      }\n      this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\n      this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\n    }\n\n    this.retrieve_tag = function (tag) { //function to retrieve the opening tag to the corresponding closer\n      if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it\n        var temp_parent = this.tags.parent; //check to see if it's a closable tag.\n        while (temp_parent) { //till we reach '' (the initial value);\n          if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it\n            break;\n          }\n          temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\n        }\n        if (temp_parent) { //if we caught something\n          this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\n          this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\n        }\n        delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\n        delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\n        if (this.tags[tag + 'count'] == 1) {\n          delete this.tags[tag + 'count'];\n        }\n        else {\n          this.tags[tag + 'count']--;\n        }\n      }\n    }\n\n    this.get_tag = function (peek) { //function to get a full tag and parse its type\n      var input_char = '',\n          content = [],\n          space = false,\n          tag_start, tag_end,\n          peek = typeof peek !== 'undefined' ? peek : false,\n          orig_pos = this.pos,\n          orig_line_char_count = this.line_char_count;\n\n      do {\n        if (this.pos >= this.input.length) {\n          if (peek) {\n            this.pos = orig_pos;\n            this.line_char_count = orig_line_char_count;\n          }\n          return content.length?content.join(''):['', 'TK_EOF'];\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++;\n        this.line_char_count++;\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\n          space = true;\n          this.line_char_count--;\n          continue;\n        }\n\n        if (input_char === \"'\" || input_char === '\"') {\n          if (!content[1] || content[1] !== '!') { //if we're in a comment strings don't get treated specially\n            input_char += this.get_unformatted(input_char);\n            space = true;\n          }\n        }\n\n        if (input_char === '=') { //no space before =\n          space = false;\n        }\n\n        if (content.length && content[content.length-1] !== '=' && input_char !== '>'\n            && space) { //no space after = or before >\n          if (this.line_char_count >= this.max_char) {\n            this.print_newline(false, content);\n            this.line_char_count = 0;\n          }\n          else {\n            content.push(' ');\n            this.line_char_count++;\n          }\n          space = false;\n        }\n        if (input_char === '<') {\n          tag_start = this.pos - 1;\n        }\n        content.push(input_char); //inserts character at-a-time (or string)\n      } while (input_char !== '>');\n\n      var tag_complete = content.join('');\n      var tag_index;\n      if (tag_complete.indexOf(' ') != -1) { //if there's whitespace, thats where the tag name ends\n        tag_index = tag_complete.indexOf(' ');\n      }\n      else { //otherwise go with the tag ending\n        tag_index = tag_complete.indexOf('>');\n      }\n      var tag_check = tag_complete.substring(1, tag_index).toLowerCase();\n      if (tag_complete.charAt(tag_complete.length-2) === '/' ||\n        this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\n        if ( ! peek) {\n          this.tag_type = 'SINGLE';\n        }\n      }\n      else if (tag_check === 'script') { //for later script handling\n        if ( ! peek) {\n          this.record_tag(tag_check);\n          this.tag_type = 'SCRIPT';\n        }\n      }\n      else if (tag_check === 'style') { //for future style handling (for now it justs uses get_content)\n        if ( ! peek) {\n          this.record_tag(tag_check);\n          this.tag_type = 'STYLE';\n        }\n      }\n      else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\n        var comment = this.get_unformatted('</'+tag_check+'>', tag_complete); //...delegate to get_unformatted function\n        content.push(comment);\n        // Preserve collapsed whitespace either before or after this tag.\n        if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)){\n            content.splice(0, 0, this.input.charAt(tag_start - 1));\n        }\n        tag_end = this.pos - 1;\n        if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)){\n            content.push(this.input.charAt(tag_end + 1));\n        }\n        this.tag_type = 'SINGLE';\n      }\n      else if (tag_check.charAt(0) === '!') { //peek for <!-- comment\n        if (tag_check.indexOf('[if') != -1) { //peek for <!--[if conditional comment\n          if (tag_complete.indexOf('!IE') != -1) { //this type needs a closing --> so...\n            var comment = this.get_unformatted('-->', tag_complete); //...delegate to get_unformatted\n            content.push(comment);\n          }\n          if ( ! peek) {\n            this.tag_type = 'START';\n          }\n        }\n        else if (tag_check.indexOf('[endif') != -1) {//peek for <!--[endif end conditional comment\n          this.tag_type = 'END';\n          this.unindent();\n        }\n        else if (tag_check.indexOf('[cdata[') != -1) { //if it's a <[cdata[ comment...\n          var comment = this.get_unformatted(']]>', tag_complete); //...delegate to get_unformatted function\n          content.push(comment);\n          if ( ! peek) {\n            this.tag_type = 'SINGLE'; //<![CDATA[ comments are treated like single tags\n          }\n        }\n        else {\n          var comment = this.get_unformatted('-->', tag_complete);\n          content.push(comment);\n          this.tag_type = 'SINGLE';\n        }\n      }\n      else if ( ! peek) {\n        if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\n          this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\n          this.tag_type = 'END';\n        }\n        else { //otherwise it's a start-tag\n          this.record_tag(tag_check); //push it on the tag stack\n          this.tag_type = 'START';\n        }\n        if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\n          this.print_newline(true, this.output);\n        }\n      }\n\n      if (peek) {\n        this.pos = orig_pos;\n        this.line_char_count = orig_line_char_count;\n      }\n\n      return content.join(''); //returns fully formatted tag\n    }\n\n    this.get_unformatted = function (delimiter, orig_tag) { //function to return unformatted content in its entirety\n\n      if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) != -1) {\n        return '';\n      }\n      var input_char = '';\n      var content = '';\n      var space = true;\n      do {\n\n        if (this.pos >= this.input.length) {\n          return content;\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n          if (!space) {\n            this.line_char_count--;\n            continue;\n          }\n          if (input_char === '\\n' || input_char === '\\r') {\n            content += '\\n';\n            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\n            for (var i=0; i<this.indent_level; i++) {\n              content += this.indent_string;\n            }\n            space = false; //...and make sure other indentation is erased\n            */\n            this.line_char_count = 0;\n            continue;\n          }\n        }\n        content += input_char;\n        this.line_char_count++;\n        space = true;\n\n\n      } while (content.toLowerCase().indexOf(delimiter) == -1);\n      return content;\n    }\n\n    this.get_token = function () { //initial handler for token-retrieval\n      var token;\n\n      if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\n       var type = this.last_token.substr(7)\n       token = this.get_contents_to(type);\n        if (typeof token !== 'string') {\n          return token;\n        }\n        return [token, 'TK_' + type];\n      }\n      if (this.current_mode === 'CONTENT') {\n        token = this.get_content();\n        if (typeof token !== 'string') {\n          return token;\n        }\n        else {\n          return [token, 'TK_CONTENT'];\n        }\n      }\n\n      if (this.current_mode === 'TAG') {\n        token = this.get_tag();\n        if (typeof token !== 'string') {\n          return token;\n        }\n        else {\n          var tag_name_type = 'TK_TAG_' + this.tag_type;\n          return [token, tag_name_type];\n        }\n      }\n    }\n\n    this.get_full_indent = function (level) {\n      level = this.indent_level + level || 0;\n      if (level < 1)\n        return '';\n\n      return Array(level + 1).join(this.indent_string);\n    }\n\n    this.is_unformatted = function(tag_check, unformatted) {\n        //is this an HTML5 block-level link?\n        if (!this.Utils.in_array(tag_check, unformatted)){\n            return false;\n        }\n\n        if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)){\n            return true;\n        }\n\n        //at this point we have an  tag; is its first child something we want to remain\n        //unformatted?\n        var next_tag = this.get_tag(true /* peek. */);\n        if (next_tag && this.Utils.in_array(next_tag, unformatted)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    this.printer = function (js_source, indent_character, indent_size, max_char, brace_style) { //handles input/output and some other printing functions\n\n      this.input = js_source || ''; //gets the input for the Parser\n      this.output = [];\n      this.indent_character = indent_character;\n      this.indent_string = '';\n      this.indent_size = indent_size;\n      this.brace_style = brace_style;\n      this.indent_level = 0;\n      this.max_char = max_char;\n      this.line_char_count = 0; //count to see if max_char was exceeded\n\n      for (var i=0; i<this.indent_size; i++) {\n        this.indent_string += this.indent_character;\n      }\n\n      this.print_newline = function (ignore, arr) {\n        this.line_char_count = 0;\n        if (!arr || !arr.length) {\n          return;\n        }\n        if (!ignore) { //we might want the extra line\n          while (this.Utils.in_array(arr[arr.length-1], this.Utils.whitespace)) {\n            arr.pop();\n          }\n        }\n        arr.push('\\n');\n        for (var i=0; i<this.indent_level; i++) {\n          arr.push(this.indent_string);\n        }\n      }\n\n      this.print_token = function (text) {\n        this.output.push(text);\n      }\n\n      this.indent = function () {\n        this.indent_level++;\n      }\n\n      this.unindent = function () {\n        if (this.indent_level > 0) {\n          this.indent_level--;\n        }\n      }\n    }\n    return this;\n  }\n\n  /*_____________________--------------------_____________________*/\n\n  multi_parser = new Parser(); //wrapping functions Parser\n  multi_parser.printer(html_source, indent_character, indent_size, max_char, brace_style); //initialize starting values\n\n  while (true) {\n      var t = multi_parser.get_token();\n      multi_parser.token_text = t[0];\n      multi_parser.token_type = t[1];\n\n    if (multi_parser.token_type === 'TK_EOF') {\n      break;\n    }\n\n    switch (multi_parser.token_type) {\n      case 'TK_TAG_START':\n        multi_parser.print_newline(false, multi_parser.output);\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.indent();\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_STYLE':\n      case 'TK_TAG_SCRIPT':\n        multi_parser.print_newline(false, multi_parser.output);\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_END':\n        //Print new line only if the tag has no content and has child\n        if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\n            var tag_name = multi_parser.token_text.match(/\\w+/)[0];\n            var tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length -1].match(/<\\s*(\\w+)/);\n            if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name)\n                multi_parser.print_newline(true, multi_parser.output);\n        }\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_SINGLE':\n        // Don't add a newline before elements that should remain unformatted.\n        var tag_check = multi_parser.token_text.match(/^\\s*<([a-z]+)/i);\n        if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)){\n            multi_parser.print_newline(false, multi_parser.output);\n        }\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_CONTENT':\n        if (multi_parser.token_text !== '') {\n          multi_parser.print_token(multi_parser.token_text);\n        }\n        multi_parser.current_mode = 'TAG';\n        break;\n      case 'TK_STYLE':\n      case 'TK_SCRIPT':\n        if (multi_parser.token_text !== '') {\n          multi_parser.output.push('\\n');\n          var text = multi_parser.token_text;\n          if (multi_parser.token_type == 'TK_SCRIPT') {\n            var _beautifier = typeof js_beautify == 'function' && js_beautify;\n          } else if (multi_parser.token_type == 'TK_STYLE') {\n            var _beautifier = typeof css_beautify == 'function' && css_beautify;\n          }\n\n          if (options.indent_scripts == \"keep\") {\n            var script_indent_level = 0;\n          } else if (options.indent_scripts == \"separate\") {\n            var script_indent_level = -multi_parser.indent_level;\n          } else {\n            var script_indent_level = 1;\n          }\n\n          var indentation = multi_parser.get_full_indent(script_indent_level);\n          if (_beautifier) {\n            // call the Beautifier if avaliable\n            text = _beautifier(text.replace(/^\\s*/, indentation), options);\n          } else {\n            // simply indent the string otherwise\n            var white = text.match(/^\\s*/)[0];\n            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\n            var reindent = multi_parser.get_full_indent(script_indent_level -_level);\n            text = text.replace(/^\\s*/, indentation)\n                   .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\n                   .replace(/\\s*$/, '');\n          }\n          if (text) {\n            multi_parser.print_token(text);\n            multi_parser.print_newline(true, multi_parser.output);\n          }\n        }\n        multi_parser.current_mode = 'TAG';\n        break;\n    }\n    multi_parser.last_token = multi_parser.token_type;\n    multi_parser.last_text = multi_parser.token_text;\n  }\n  return multi_parser.output.join('');\n}\n"]}