{"version":3,"sources":["../../../../../src/config/default/mode/lua/lua_parse.js"],"names":["define","require","exports","module","root","name","factory","version","input","options","length","defaultOptions","wait","comments","scope","locations","ranges","EOF","StringLiteral","Keyword","Identifier","NumericLiteral","Punctuator","BooleanLiteral","NilLiteral","VarargLiteral","tokenTypes","errors","unexpected","expected","expectedToken","unfinishedString","malformedNumber","ast","labelStatement","label","type","breakStatement","gotoStatement","returnStatement","args","ifStatement","clauses","ifClause","condition","body","elseifClause","elseClause","whileStatement","doStatement","repeatStatement","localStatement","variables","init","assignmentStatement","callStatement","expression","functionStatement","identifier","parameters","isLocal","forNumericStatement","variable","start","end","step","forGenericStatement","iterators","chunk","literal","value","raw","tableKey","key","tableKeyString","tableValue","tableConstructorExpression","fields","binaryExpression","operator","left","right","unaryExpression","argument","memberExpression","base","indexer","indexExpression","index","callExpression","tableCallExpression","stringCallExpression","comment","finishNode","node","trackLocations","location","pop","complete","loc","range","slice","Array","prototype","toString","Object","indexOf","array","element","i","indexOfObject","property","sprintf","format","call","arguments","replace","match","extend","dest","src","prop","hasOwnProperty","raise","token","message","apply","error","col","line","lineStart","SyntaxError","column","raiseUnexpectedToken","found","near","lookahead","previousToken","tokenStart","lex","skipWhiteSpace","charCodeAt","scanComment","charCode","next","isIdentifierStart","scanIdentifierOrKeyword","scanStringLiteral","scanNumericLiteral","isDecDigit","scanVarargLiteral","scanPunctuator","scanLongStringLiteral","charAt","isWhiteSpace","isLineTerminator","isIdentifierPart","isKeyword","delimiter","stringStart","string","readEscapeSequence","String","fromCharCode","readLongString","character","readHexLiteral","readDecLiteral","fraction","binaryExponent","binarySign","digit","fractionStart","exponentStart","digitStart","isHexDigit","parseInt","Math","pow","parseFloat","sequenceStart","content","isLong","commentStart","lineStartComment","lineComment","push","level","terminator","consume","expect","id","isUnary","isCallExpression","isBlockFollow","scopes","scopeDepth","globals","createScope","exitScope","scopeIdentifierName","scopeIdentifier","attachScope","scopeHasName","createLocationMarker","Marker","markLocation","pushLocation","marker","parseChunk","parseBlock","block","statement","parseStatement","parseLocalStatement","parseIfStatement","parseReturnStatement","parseFunctionName","parseFunctionDeclaration","parseWhileStatement","parseForStatement","parseRepeatStatement","parseBreakStatement","parseDoStatement","parseGotoStatement","parseLabelStatement","parseAssignmentOrCallStatement","parseIdentifier","isLabel","parseExpectedExpression","expressions","parseExpression","l","previous","parsePrefixExpression","exp","parameter","parsePrimaryExpression","parseTableConstructor","parseSubExpression","binaryPrecedence","minPrecedence","precedence","parseCallExpression","table","literals","parse","_input","_options","undefined","write","Error"],"mappings":"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","file":"lua_parse.js","sourcesContent":["define(function(require, exports, module) {\n/*global exports:true module:true require:true define:true global:true */\n\n(function (root, name, factory) {\n   factory(exports)\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = '0.1.4';\n\n  var input, options, length;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'Unexpected %1 \\'%2\\' near \\'%3\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      if (options.locations) node.loc = location.loc;\n      if (options.ranges) node.range = location.range;\n    }\n    return node;\n  }\n\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    , indexOf = function indexOf(array, element) {\n      for (var i = 0, length = array.length; i < length; i++) {\n        if (array[i] === element) return i;\n      }\n      return -1;\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; i++) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || '';\n    });\n    return format;\n  }\n\n  // Returns a new object with the properties from all objectes passed as\n  // arguments. Last argument takes precedence.\n  //\n  // Example:\n  //\n  //     this.options = extend(options, { output: false });\n\n  function extend() {\n    var args = slice.call(arguments)\n      , dest = {}\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; i++) {\n      src = args[i];\n      for (prop in src) if (src.hasOwnProperty(prop)) {\n        dest[prop] = src[prop];\n      }\n    }\n    return dest;\n  }\n\n  // ### Error functions\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if ('undefined' !== typeof token.line) {\n      col = token.range[0] - token.lineStart;\n      error = new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    } else {\n      col = index - lineStart + 1;\n      error = new SyntaxError(sprintf('[%1:%2] %3', line, col, message));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    }\n    throw error;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, token.value);\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found, near) {\n    if ('undefined' === typeof near) near = lookahead.value;\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n      }\n      return raise(found, errors.unexpected, type, found.value, near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      // 0-9\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57:\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        return raise({}, errors.expected, '=', '~');\n\n      case 58: // :\n        if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      // \\* / ^ % , { } ] ( ) ; # - +\n      case 42: case 47: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45: case 43:\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Newlines are also tracked in all\n  // token functions where multiline values are allowed.\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        index++;\n      } else if (isLineTerminator(charCode)) {\n        line++;\n        lineStart = ++index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = input.slice(tokenStart, index);\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , stringStart = index\n      , string = ''\n      , charCode;\n\n    while (index < length) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      if (92 === charCode) { // \\\n        string += input.slice(stringStart, index - 1) + readEscapeSequence();\n        stringStart = index;\n      }\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      else if (index >= length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise({}, errors.unfinishedString, string + String.fromCharCode(charCode));\n      }\n    }\n    string += input.slice(stringStart, index - 1);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var string = readLongString();\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', token.value);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var value = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    return {\n        type: NumericLiteral\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) index++;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part i optional.\n    if ('.' === input.charAt(index)) {\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) index++;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return (digit + fraction) * binaryExponent;\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) index++;\n    // Fraction part is optional\n    if ('.' === input.charAt(index)) {\n      index++;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n    // Exponent part is optional.\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) index++;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n\n    return parseFloat(input.slice(tokenStart, index));\n  }\n\n\n  // Translate escape sequences to the actual characters.\n\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      // We don't escape the bell sequence.\n      case 'n': index++; return '\\n';\n      case 'r': index++; return '\\r';\n      case 't': index++; return '\\t';\n      case 'v': index++; return '\\x0B';\n      case 'b': index++; return '\\b';\n      case 'f': index++; return '\\f';\n      // Skips the following span of white-space.\n      case 'z': index++; skipWhiteSpace(); return '';\n      // Byte representation should for now be returned as is.\n      case 'x':\n        // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n        if (isHexDigit(input.charCodeAt(index + 1)) &&\n            isHexDigit(input.charCodeAt(index + 2))) {\n          index += 3;\n          // Return it as is, without translating the byte.\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        return '\\\\' + input.charAt(index++);\n      default:\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        if (isDecDigit(input.charCodeAt(index))) {\n          while (isDecDigit(input.charCodeAt(++index)));\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        // Simply return the \\ as is, it's not escaping any sequence.\n        return input.charAt(index++);\n    }\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString();\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        index++;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString() {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart;\n\n    index++; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) level++;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) {\n      line++;\n      lineStart = index++;\n    }\n\n    stringStart = index;\n    while (index < length) {\n      character = input.charAt(index++);\n\n      // We have to keep track of newlines as `skipWhiteSpace()` does not get\n      // to scan this part.\n      if (isLineTerminator(character.charCodeAt(0))) {\n        line++;\n        lineStart = index;\n      }\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; i++) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) break;\n    }\n    content += input.slice(stringStart, index - 1);\n    index += level + 1;\n\n    return content;\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, token.value);\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use locale-dependet letters.\n\n  function isIdentifierStart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode;\n  }\n\n  function isIdentifierPart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57);\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        return 'else' === id || 'goto' === id || 'then' === id;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // @TODO this needs to be rethought.\n  function isCallExpression(expression) {\n    switch (expression.type) {\n      case 'CallExpression':\n      case 'TableCallExpression':\n      case 'StringCallExpression':\n        return true;\n    }\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    scopes.push(Array.apply(null, scopes[scopeDepth++]));\n  }\n\n  // Exit and remove the current scope.\n  function exitScope() {\n    scopes.pop();\n    scopeDepth--;\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.line;\n      this.loc.end.column = previousToken.range[1] - previousToken.lineStart;\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    var body = parseBlock();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(terminator) {\n    var block = []\n      , statement;\n\n    // Each block creates a new scope.\n    if (options.scope) createScope();\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      if ('return' === token.value) {\n        block.push(parseStatement());\n        break;\n      }\n      statement = parseStatement();\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    if (options.scope) exitScope();\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement() {\n    markLocation();\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement();\n        case 'if':       next(); return parseIfStatement();\n        case 'return':   next(); return parseReturnStatement();\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement();\n        case 'for':      next(); return parseForStatement();\n        case 'repeat':   next(); return parseRepeatStatement();\n        case 'break':    next(); return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement();\n        case 'goto':     next(); return parseGotoStatement();\n      }\n    }\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement();\n    }\n    // Assignments memorizes the location and pushes it manually for wrapper\n    // nodes. Additionally empty `;` statements should not mark a location.\n    if (trackLocations) locations.pop();\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (consume(';')) return;\n\n    return parseAssignmentOrCallStatement();\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + name + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    if (options.scope) label.isLabel = scopeHasName('::' + name + '::');\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement() {\n    var body = parseBlock();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement() {\n    var condition = parseExpectedExpression();\n    expect('do');\n    var body = parseBlock();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement() {\n    var body = parseBlock();\n    expect('until');\n    var condition = parseExpectedExpression();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement() {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression();\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression();\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement() {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression();\n    expect('then');\n    body = parseBlock();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression();\n      expect('then');\n      body = parseBlock();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      body = parseBlock();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement() {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n    if (options.scope) scopeIdentifier(variable);\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression();\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression();\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression() : null;\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression();\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}\n\n  function parseLocalStatement() {\n    var name;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression();\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; i++) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      if (options.scope) scopeIdentifier(name);\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     varlist ::= prefixexp {',' prefixexp}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement() {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    expression = parsePrefixExpression();\n\n    if (null == expression) return unexpected(token);\n    if (',='.indexOf(token.value) >= 0) {\n      var variables = [expression]\n        , init = []\n        , exp;\n\n      while (consume(',')) {\n        exp = parsePrefixExpression();\n        if (null == exp) raiseUnexpectedToken('<expression>', token);\n        variables.push(exp);\n      }\n      expect('=');\n      do {\n        exp = parseExpectedExpression();\n        init.push(exp);\n      } while (consume(','));\n\n      pushLocation(marker);\n      return finishNode(ast.assignmentStatement(variables, init));\n    }\n    if (isCallExpression(expression)) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(expression));\n    }\n    // The prefix expression was neither part of an assignment or a\n    // callstatement, however as it was valid it's been consumed, so raise\n    // the exception on the previous token to provide a helpful message.\n    return unexpected(previous);\n  }\n\n\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n          else if (consume(')')) break;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          parameters.push(parsePrimaryExpression());\n          expect(')');\n          break;\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n      }\n    }\n\n    var body = parseBlock();\n    expect('end');\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) attachScope(base, false);\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      if (options.scope) attachScope(name, false);\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      if (options.scope) attachScope(name, false);\n      base = finishNode(ast.memberExpression(base, ':', name));\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor() {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression();\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression();\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        key = parseExpectedExpression();\n        if (consume('=')) {\n          value = parseExpectedExpression();\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          fields.push(finishNode(ast.tableValue(key)));\n        }\n      } else {\n        if (null == (value = parseExpression())) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      if ('}' === token.value) break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression() {\n    var expression = parseSubExpression(0);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression() {\n    var expression = parseExpression();\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 10; // ^\n        case 42: case 47: case 37: return 7; // * / %\n        case 43: case 45: return 6; // + -\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 46: return 5; // ..\n        case 60: case 62: case 61: case 126: return 3; // <= >= == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(8);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression();\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression();\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) precedence--;\n      next();\n      var right = parseSubExpression(precedence);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpression() {\n    var base, name, marker\n      // Keep track of the scope, if a parent is local so are the children.\n      , isLocal;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, isLocal = scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression();\n      expect(')');\n      if (options.scope) isLocal = base.isLocal;\n    } else {\n      return null;\n    }\n\n    // The suffix\n    var expression, identifier;\n    while (true) {\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '[':\n            pushLocation(marker);\n            next();\n            expression = parseExpectedExpression();\n            base = finishNode(ast.indexExpression(base, expression));\n            expect(']');\n            break;\n          case '.':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            // Inherit the scope\n            if (options.scope) attachScope(identifier, isLocal);\n            base = finishNode(ast.memberExpression(base, '.', identifier));\n            break;\n          case ':':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            if (options.scope) attachScope(identifier, isLocal);\n            base = finishNode(ast.memberExpression(base, ':', identifier));\n            // Once a : is found, this has to be a CallExpression, otherwise\n            // throw an error.\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          case '(': case '{': // args\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          default:\n            return base;\n        }\n      } else if (StringLiteral === token.type) {\n        pushLocation(marker);\n        base = parseCallExpression(base);\n      } else {\n        break;\n      }\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression();\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression();\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor();\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression()));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression() {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor();\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = extend(defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n\n});"]}